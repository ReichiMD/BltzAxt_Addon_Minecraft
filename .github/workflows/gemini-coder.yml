      - name: Create Builder Script
        run: |
          cat << 'EOF' > builder.py
          import os
          import json
          import requests
          import glob
          import zipfile
          import shutil
          import re
          import sys

          # SAFE ENV FETCHING
          API_KEY = os.environ.get('GEMINI_API_KEY')
          if not API_KEY:
              print("❌ ERROR: API Key missing!")
              sys.exit(1)
              
          # HIER WAR DER KOPIER-FEHLER. JETZT SAUBER:
          BASE_URL = "https://generativelanguage.googleapis.com/v1beta"
          USER_REQUEST = os.environ.get('ISSUE_BODY', '')

          def call_gemini(prompt, model='models/gemini-1.5-flash'):
              # URL Zusammenbau
              url = f"{BASE_URL}/{model}:generateContent?key={API_KEY}"
              
              payload = {'contents': [{'parts': [{'text': prompt}]}]}
              try:
                  response = requests.post(url, json=payload, headers={'Content-Type': 'application/json'})
                  if response.status_code != 200: 
                      print(f"API Error Status: {response.status_code}")
                      print(f"Response: {response.text}")
                      return None
                  
                  text = response.json()['candidates'][0]['content']['parts'][0]['text']
                  # Clean Markdown (Safe Regex)
                  text = re.sub(r'^```json\s*', '', text, flags=re.MULTILINE)
                  text = re.sub(r'^```\s*', '', text, flags=re.MULTILINE)
                  return text.strip()
              except Exception as e:
                  print(f"API Exception: {e}")
                  return None

          # --- 1. RESET LOGIK ---
          if 'RESET PROJECT' in USER_REQUEST:
              print('!!! RESET PROJECT AUSGEFÜHRT !!!')
              if os.path.exists('BP'): shutil.rmtree('BP')
              if os.path.exists('RP'): shutil.rmtree('RP')
              manifest_content = ''
          else:
              manifest_content = ''
              for m_path in ['BP/manifest.json', 'RP/manifest.json', 'manifest.json']:
                  if os.path.exists(m_path):
                      try:
                          with open(m_path, 'r', encoding='utf-8') as f:
                              manifest_content += f'\n--- EXISTING ({m_path}) ---\n' + f.read()
                      except: pass

          # --- 2. DOCS FILTER ---
          try:
              with open('README.md', 'r', encoding='utf-8') as f: readme_content = f.read()
          except: readme_content = 'No rules found.'

          docs_content = ''
          doc_files = glob.glob('docs/**/*.zip', recursive=True)
          # KEYWORDS fuer Filter
          KEYWORDS = ['script', 'server', 'event', 'world', 'system', 'component', 'recipe', 'item', 'group'] 

          for file_path in doc_files:
              try:
                  with zipfile.ZipFile(file_path, 'r') as z:
                      for z_filename in z.namelist():
                          if z_filename.endswith('.md') or z_filename.endswith('.txt'):
                              is_relevant = any(k in z_filename.lower() for k in KEYWORDS)
                              if 'best_practices' in z_filename.lower(): is_relevant = True
                              if is_relevant:
                                  try:
                                      with z.open(z_filename) as zf:
                                          c = zf.read().decode('utf-8', errors='ignore')
                                          if len(c) < 25000: docs_content += f'\n--- DOCS: {z_filename} ---\n' + c
                                  except: pass
              except: pass
          
          for txt_path in glob.glob('docs/**/*.txt', recursive=True):
               with open(txt_path, 'r', encoding='utf-8') as f: docs_content += f.read() + '\n'

          # --- 3. GENERATION ---
          print('--- STARTE GENERIERUNG ---')
          prompt = f"""
          You are a Minecraft Bedrock Addon Expert (1.21+).
          CONTEXT:
          {docs_content[:150000]} 
          --- RULES ---
          {readme_content}
          --- CURRENT STATE ---
          {manifest_content}
          
          TASK: {USER_REQUEST}
          
          OUTPUT: Valid JSON ONLY: {{"path/file.json": "content"}}
          STRICT: No markdown, no explanations.
          """
          
          json_response = call_gemini(prompt)
          
          if not json_response:
              print('❌ FEHLER: Keine Antwort von API.')
              sys.exit(1)

          try:
              data = json.loads(json_response)
          except:
              s = json_response.find('{')
              e = json_response.rfind('}') + 1
              try:
                  data = json.loads(json_response[s:e])
              except:
                  print("❌ JSON Parsing failed heavily.")
                  sys.exit(1)

          # --- 4. SELF-HEALING ---
          print('--- PRÜFE & SCHREIBE DATEIEN ---')
          for path, content in data.items():
              directory = os.path.dirname(path)
              if directory: os.makedirs(directory, exist_ok=True)
              
              str_content = json.dumps(content, indent=4) if isinstance(content, (dict, list)) else str(content)
              
              if path.endswith('.json'):
                  try:
                      json.loads(str_content)
                  except Exception as e:
                      print(f'⚠️ Invalid JSON in {path}: {e}. Fixing...')
                      fix_prompt = f'Fix this invalid JSON ({path}). Error: {e}\n\nInvalid Content:\n{str_content}\n\nReturn ONLY valid JSON string.'
                      fixed = call_gemini(fix_prompt)
                      if fixed:
                          try:
                              json.loads(fixed)
                              str_content = fixed
                              print(f'✅ {path} REPARIERT!')
                          except:
                              print(f'❌ Reparatur fehlgeschlagen für {path}.')
                              continue

              with open(path, 'w', encoding='utf-8') as f: f.write(str_content)
              print(f'Geschrieben: {path}')
          EOF
          
