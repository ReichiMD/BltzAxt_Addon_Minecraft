name: Gemini Addon Generator

on:
  issues:
    types: [opened, edited]

permissions:
  contents: write
  pull-requests: write

jobs:
  build-addon:
    if: contains(github.event.issue.title, 'Gemini')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Requests
        run: pip install requests

      - name: Run Generator (Robust Save Fix)
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          python -c "
          import os
          import json
          import requests
          import glob

          API_KEY = os.environ['GEMINI_API_KEY']
          BASE_URL = 'https://generativelanguage.googleapis.com/v1beta'

          # 1. README LESEN
          try:
              with open('README.md', 'r', encoding='utf-8') as f:
                  readme_content = f.read()
              print('--- README geladen ---')
          except:
              readme_content = 'No rules found.'
              print('--- INFO: Keine README gefunden ---')

          # 2. DOKUMENTATION LESEN
          docs_content = ''
          doc_files = glob.glob('docs/**/*.md', recursive=True) + glob.glob('docs/**/*.txt', recursive=True)
          
          if doc_files:
              print(f'--- Lade {len(doc_files)} Doku-Dateien ---')
              for file_path in doc_files:
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          filename = os.path.basename(file_path)
                          docs_content += f'\n--- DOCUMENTATION: {filename} ---\n'
                          docs_content += f.read() + '\n'
                  except: pass
          else:
              print('--- INFO: Keine Docs gefunden. ---')

          # 3. EXISTIERENDE MANIFESTS LESEN
          manifest_content = ''
          for m_path in ['BP/manifest.json', 'RP/manifest.json', 'manifest.json']:
              if os.path.exists(m_path):
                  try:
                      with open(m_path, 'r', encoding='utf-8') as f:
                          manifest_content += f'\n--- EXISTING FILE ({m_path}) ---\n'
                          manifest_content += f.read() + '\n'
                      print(f'Gelesen für Update: {m_path}')
                  except: pass

          # 4. KI Auswahl
          def get_working_model():
              print('--- Modell-Suche ---')
              try:
                  url = f'{BASE_URL}/models?key={API_KEY}'
                  response = requests.get(url)
                  if response.status_code != 200: return None
                  data = response.json()
                  models = data.get('models', [])
                  valid_models = [m['name'] for m in models if 'generateContent' in m.get('supportedGenerationMethods', [])]
                  
                  if not valid_models: return None

                  # Bevorzuge Flash 1.5
                  for vm in valid_models:
                      if 'flash' in vm and '1.5' in vm:
                          print(f'--- GEWÄHLT: {vm} (Flash 1.5) ---')
                          return vm
                  return valid_models[0]
              except: return None

          model_name = get_working_model() or 'models/gemini-1.5-flash'
          URL = f'{BASE_URL}/{model_name}:generateContent?key={API_KEY}'
          
          # 5. Der Prompt
          prompt_text = f'''
          You are a Minecraft Bedrock Addon Expert.
          
          --- KNOWLEDGE BASE (DOCS) ---
          {docs_content}
          
          --- PROJECT RULES (README) ---
          {readme_content}
          
          --- CURRENT PROJECT STATE (EXISTING FILES) ---
          IMPORTANT: If manifests exist below, use their UUIDs and increment the version number. 
          DO NOT generate new UUIDs if they are listed here:
          {manifest_content}
          --- END STATE ---
          
          TECHNICAL CONSTRAINTS:
          1. Output ONLY valid JSON. format: {{\"path/file.json\": \"content\"}}
          2. NO markdown blocks. NO text before/after.
          3. Ensure manifest.json is included (updated version).
          '''
          
          user_request = os.environ['ISSUE_BODY']
          
          payload = {
              'contents': [{
                  'parts': [{'text': prompt_text + '\nUSER REQUEST: ' + user_request}]
              }]
          }

          print(f'Sende Auftrag an {model_name}...')
          
          try:
              response = requests.post(URL, json=payload, headers={'Content-Type': 'application/json'})
              if response.status_code != 200:
                  print('API ERROR:', response.text)
                  exit(1)
              
              result = response.json()
              text = result['candidates'][0]['content']['parts'][0]['text']
              
              text = text.strip()
              if text.startswith('\`\`\`json'): text = text[7:]
              if text.startswith('\`\`\`'): text = text[3:]
              text = text.replace('\`\`\`json', '').replace('\`\`\`', '').strip()

              data = json.loads(text)
              
              for path, content in data.items():
                  directory = os.path.dirname(path)
                  if directory: os.makedirs(directory, exist_ok=True)
                  
                  # HIER IST DER FIX: Wir prüfen, was ankommt
                  mode = 'w'
                  write_content = content
                  
                  # Wenn die KI ein Objekt schickt, wandeln wir es in JSON-Text um
                  if isinstance(content, (dict, list)):
                      write_content = json.dumps(content, indent=4)
                  # Wenn es kein String ist, machen wir es sicherheitshalber zum String
                  elif not isinstance(content, str):
                      write_content = str(content)

                  with open(path, 'w', encoding='utf-8') as f:
                      f.write(write_content)
                  print(f'Datei erstellt/aktualisiert: {path}')

          except Exception as e:
              print(f'FEHLER: {e}')
              exit(1)
          "

      - name: Commit changes
        run: |
          git config --global user.name "Gemini Bot"
          git config --global user.email "bot@noreply.github.com"
          git add .
          git commit -m "Gemini generated addon files" || echo "No changes"
          git push
          
